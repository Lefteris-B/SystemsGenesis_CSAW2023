#include <defs.h>
#include <stub.c>


// access all housekeeping registers that can be access through firmware and change it's value
void main(){
    reg_wb_enable =1; // for enable writing to reg_debug_1 and reg_debug_2
    reg_debug_1  = 0x0;
    reg_debug_2  = 0x0;
    // store RO value regs 
    int old_reg_hkspi_status = reg_hkspi_status;
    int old_reg_hkspi_chip_id = reg_hkspi_chip_id;
    int old_reg_hkspi_user_id = reg_hkspi_user_id;
    int old_reg_hkspi_trap = reg_hkspi_trap;
    int old_reg_hkspi_irq = reg_hkspi_irq;
    // write 1 ones to all registers
    reg_mprj_io_0   = 0xFFFFFFFF;
    reg_mprj_io_1   = 0xFFFFFFFF;
    reg_mprj_io_2   = 0xFFFFFFFF;
    reg_mprj_io_3   = 0xFFFFFFFF;
    reg_mprj_io_4   = 0xFFFFFFFF;
    reg_mprj_io_5   = 0xFFFFFFFF;
    reg_mprj_io_6   = 0xFFFFFFFF;
    reg_mprj_io_7   = 0xFFFFFFFF;
    reg_mprj_io_8   = 0xFFFFFFFF;
    reg_mprj_io_9   = 0xFFFFFFFF;
    reg_mprj_io_10  = 0xFFFFFFFF;
    reg_mprj_io_11  = 0xFFFFFFFF;
    reg_mprj_io_12  = 0xFFFFFFFF;
    reg_mprj_io_13  = 0xFFFFFFFF;
    reg_mprj_io_14  = 0xFFFFFFFF;
    reg_mprj_io_15  = 0xFFFFFFFF;
    reg_mprj_io_16  = 0xFFFFFFFF;
    reg_mprj_io_17  = 0xFFFFFFFF;
    reg_mprj_io_18  = 0xFFFFFFFF;
    reg_mprj_io_19  = 0xFFFFFFFF;
    reg_mprj_io_20  = 0xFFFFFFFF;
    reg_mprj_io_21  = 0xFFFFFFFF;
    reg_mprj_io_22  = 0xFFFFFFFF;
    reg_mprj_io_23  = 0xFFFFFFFF;
    reg_mprj_io_24  = 0xFFFFFFFF;
    reg_mprj_io_25  = 0xFFFFFFFF;
    reg_mprj_io_26  = 0xFFFFFFFF;
    reg_mprj_io_27  = 0xFFFFFFFF;
    reg_mprj_io_28  = 0xFFFFFFFF;
    reg_mprj_io_29  = 0xFFFFFFFF;
    reg_mprj_io_30  = 0xFFFFFFFF;
    reg_mprj_io_31  = 0xFFFFFFFF;
    reg_mprj_io_32  = 0xFFFFFFFF;
    reg_mprj_io_33  = 0xFFFFFFFF;
    reg_mprj_io_34  = 0xFFFFFFFF;
    reg_mprj_io_35  = 0xFFFFFFFF;
    reg_mprj_io_36  = 0xFFFFFFFF;
    reg_mprj_io_37  = 0xFFFFFFFF;
    // house keeping 
    reg_hkspi_status = 0xFFFFFFFF;   
    reg_hkspi_chip_id   = 0xFFFFFFFF;   
    reg_hkspi_user_id  = 0xFFFFFFFF;    
    reg_hkspi_pll_ena   = 0xFFFFFFFF;   
    reg_hkspi_pll_bypass  = 0xFFFFFFFF; 
    reg_hkspi_irq 	      = 0xFFFFFFFF; 
    // reg_hkspi_reset      = 0xFFFFFFFF;   can't write 1 to it cpu would be reset
    reg_hkspi_trap 	      = 0xFFFFFFFF; 
    reg_hkspi_pll_trim   = 0xFFFFFFFF; 
    reg_hkspi_pll_source = 0xFFFFFFFF;  
    reg_hkspi_pll_divider = 0xFFFFFFFF;
    // sys 
    reg_clk_out_dest =  0xFFFFFFFF; 
    reg_hkspi_disable     = 0xFFFFFFFF; 

    // read ones that has been written
    if (reg_mprj_io_0 != 0x1FFF)
        reg_debug_1 =0x1;
    if (reg_mprj_io_1 != 0x1FFF)
        reg_debug_1 =0x2;
    if (reg_mprj_io_2   != 0x1FFF)
        reg_debug_1 =0x3;
    if (reg_mprj_io_3   != 0x1FFF)
        reg_debug_1 =0x4;
    if (reg_mprj_io_4   != 0x1FFF)
        reg_debug_1 =0x5;
    if (reg_mprj_io_5   != 0x1FFF)
        reg_debug_1 =0x6;
    if (reg_mprj_io_6   != 0x1FFF)
        reg_debug_1 =0x7;
    if (reg_mprj_io_7   != 0x1FFF)
        reg_debug_1 =0x8;
    if (reg_mprj_io_8   != 0x1FFF)
        reg_debug_1 =0x9;
    if (reg_mprj_io_9   != 0x1FFF)
        reg_debug_1 =0xa;
    if (reg_mprj_io_10  != 0x1FFF)
        reg_debug_1 =0xb;
    if (reg_mprj_io_11  != 0x1FFF)
        reg_debug_1 =0xc;
    if (reg_mprj_io_12  != 0x1FFF)
        reg_debug_1 =0xd;
    if (reg_mprj_io_13  != 0x1FFF)
        reg_debug_1 =0xe;
    if (reg_mprj_io_14  != 0x1FFF)
        reg_debug_1 =0xf;
    if (reg_mprj_io_15  != 0x1FFF)
        reg_debug_1 =0x10;
    if (reg_mprj_io_16  != 0x1FFF)
        reg_debug_1 =0x11;
    if (reg_mprj_io_17  != 0x1FFF)
        reg_debug_1 =0x12;
    if (reg_mprj_io_18  != 0x1FFF)
        reg_debug_1 =0x13;
    if (reg_mprj_io_19  != 0x1FFF)
        reg_debug_1 =0x14;
    if (reg_mprj_io_20  != 0x1FFF)
        reg_debug_1 =0x15;
    if (reg_mprj_io_21  != 0x1FFF)
        reg_debug_1 =0x16;
    if (reg_mprj_io_22  != 0x1FFF)
        reg_debug_1 =0x17;
    if (reg_mprj_io_23  != 0x1FFF)
        reg_debug_1 =0x18;
    if (reg_mprj_io_24  != 0x1FFF)
        reg_debug_1 =0x19;
    if (reg_mprj_io_25  != 0x1FFF)
        reg_debug_1 =0x1a;
    if (reg_mprj_io_26  != 0x1FFF)
        reg_debug_1 =0x1b;
    if (reg_mprj_io_27  != 0x1FFF)
        reg_debug_1 =0x1c;
    if (reg_mprj_io_28  != 0x1FFF)
        reg_debug_1 =0x1d;
    if (reg_mprj_io_29  != 0x1FFF)
        reg_debug_1 =0x1e;
    if (reg_mprj_io_30  != 0x1FFF)
        reg_debug_1 =0x1f;
    if (reg_mprj_io_31  != 0x1FFF)
        reg_debug_1 =0x20;
    if (reg_mprj_io_32  != 0x1FFF)
        reg_debug_1 =0x21;
    if (reg_mprj_io_33  != 0x1FFF)
        reg_debug_1 =0x22;
    if (reg_mprj_io_34  != 0x1FFF)
        reg_debug_1 =0x23;
    if (reg_mprj_io_35  != 0x1FFF)
        reg_debug_1 =0x24;
    if (reg_mprj_io_36  != 0x1FFF)
        reg_debug_1 =0x25;
    if (reg_mprj_io_37  != 0x1FFF)
        reg_debug_1 =0x26;
    // housekeeping
    if (reg_hkspi_status  != old_reg_hkspi_status) // RO
        reg_debug_1 =0x27;
    if (reg_hkspi_chip_id  != old_reg_hkspi_chip_id) // RO
        reg_debug_1 =0x28;
    if (reg_hkspi_user_id  != old_reg_hkspi_user_id) // RO
        reg_debug_1 =0x29;
    if (reg_hkspi_pll_ena  != 0x3)  // size =2
        reg_debug_1 =0x2a;
    if (reg_hkspi_pll_bypass != 0x1) // size = 1
        reg_debug_1 = 0x2b;
    if (reg_hkspi_irq  != old_reg_hkspi_irq)  // RO
        reg_debug_1 = 0x2c;
    if (reg_hkspi_trap  != old_reg_hkspi_trap)  // RO
        reg_debug_1 =0x2d;
    if (reg_hkspi_pll_trim  != 0x3FFFFFF) // size 26
        reg_debug_1 = 0x2f;
    if (reg_hkspi_pll_source  != 0x3F) // size 6 bits 0-2 = phase 0 divider, bits 3-5 = phase 90 divider
        reg_debug_1 =0x2f;
    if (reg_hkspi_pll_divider  != 0x1F) // size 7 -> PLL output divider, PLL output divider2 , PLL feedback divider
        reg_debug_1 =0x30;
    if (reg_hkspi_disable  != 0x1) // size 1
        reg_debug_1 =0x31;
    if (reg_clk_out_dest  != 0x7) // trap and clocks redirect
        reg_debug_1 =0x32;
    // // write zeros to all registers
    reg_mprj_io_0   = 0x0;
    reg_mprj_io_1   = 0x0;
    reg_mprj_io_2   = 0x0;
    reg_mprj_io_3   = 0x0;
    reg_mprj_io_4   = 0x0;
    reg_mprj_io_5   = 0x0;
    reg_mprj_io_6   = 0x0;
    reg_mprj_io_7   = 0x0;
    reg_mprj_io_8   = 0x0;
    reg_mprj_io_9   = 0x0;
    reg_mprj_io_10  = 0x0;
    reg_mprj_io_11  = 0x0;
    reg_mprj_io_12  = 0x0;
    reg_mprj_io_13  = 0x0;
    reg_mprj_io_14  = 0x0;
    reg_mprj_io_15  = 0x0;
    reg_mprj_io_16  = 0x0;
    reg_mprj_io_17  = 0x0;
    reg_mprj_io_18  = 0x0;
    reg_mprj_io_19  = 0x0;
    reg_mprj_io_20  = 0x0;
    reg_mprj_io_21  = 0x0;
    reg_mprj_io_22  = 0x0;
    reg_mprj_io_23  = 0x0;
    reg_mprj_io_24  = 0x0;
    reg_mprj_io_25  = 0x0;
    reg_mprj_io_26  = 0x0;
    reg_mprj_io_27  = 0x0;
    reg_mprj_io_28  = 0x0;
    reg_mprj_io_29  = 0x0;
    reg_mprj_io_30  = 0x0;
    reg_mprj_io_31  = 0x0;
    reg_mprj_io_32  = 0x0;
    reg_mprj_io_33  = 0x0;
    reg_mprj_io_34  = 0x0;
    reg_mprj_io_35  = 0x0;
    reg_mprj_io_36  = 0x0;
    reg_mprj_io_37  = 0x0;
    // house keeping 
    reg_hkspi_status = 0x0;   
    reg_hkspi_chip_id   = 0x0;   
    reg_hkspi_user_id  = 0x0;    
    reg_hkspi_pll_ena   = 0x0;   
    reg_hkspi_pll_bypass  = 0x0; 
    reg_hkspi_irq 	      = 0x0; 
    reg_hkspi_reset      = 0x0;  
    reg_hkspi_trap 	      = 0x0; 
    reg_hkspi_pll_trim   = 0x0; 
    reg_hkspi_pll_source = 0x0;  
    reg_hkspi_pll_divider = 0x0;
    // sys 
    reg_clk_out_dest =  0x0; 
    reg_hkspi_disable     = 0x0; 

    // // read zeros that has been written
    if (reg_mprj_io_0 != 0x0)
        reg_debug_2 =0x1;
    if (reg_mprj_io_1 != 0x0)
        reg_debug_2 =0x2;
    if (reg_mprj_io_2 != 0x0)
        reg_debug_2 =0x3;
    if (reg_mprj_io_3 != 0x0)
        reg_debug_2 =0x4;
    if (reg_mprj_io_4 != 0x0)
        reg_debug_2 =0x5;
    if (reg_mprj_io_5 != 0x0)
        reg_debug_2 =0x6;
    if (reg_mprj_io_6 != 0x0)
        reg_debug_2 =0x7;
    if (reg_mprj_io_7 != 0x0)
        reg_debug_2 =0x8;
    if (reg_mprj_io_8 != 0x0)
        reg_debug_2 =0x9;
    if (reg_mprj_io_9 != 0x0)
        reg_debug_2 =0xa;
    if (reg_mprj_io_10 != 0x0)
        reg_debug_2 =0xb;
    if (reg_mprj_io_11 != 0x0)
        reg_debug_2 =0xc;
    if (reg_mprj_io_12 != 0x0)
        reg_debug_2 =0xd;
    if (reg_mprj_io_13 != 0x0)
        reg_debug_2 =0xe;
    if (reg_mprj_io_14 != 0x0)
        reg_debug_2 =0xf;
    if (reg_mprj_io_15 != 0x0)
        reg_debug_2 =0x10;
    if (reg_mprj_io_16 != 0x0)
        reg_debug_2 =0x11;
    if (reg_mprj_io_17 != 0x0)
        reg_debug_2 =0x12;
    if (reg_mprj_io_18 != 0x0)
        reg_debug_2 =0x13;
    if (reg_mprj_io_19 != 0x0)
        reg_debug_2 =0x14;
    if (reg_mprj_io_20 != 0x0)
        reg_debug_2 =0x15;
    if (reg_mprj_io_21 != 0x0)
        reg_debug_2 =0x16;
    if (reg_mprj_io_22 != 0x0)
        reg_debug_2 =0x17;
    if (reg_mprj_io_23 != 0x0)
        reg_debug_2 =0x18;
    if (reg_mprj_io_24 != 0x0)
        reg_debug_2 =0x19;
    if (reg_mprj_io_25 != 0x0)
        reg_debug_2 =0x1a;
    if (reg_mprj_io_26 != 0x0)
        reg_debug_2 =0x1b;
    if (reg_mprj_io_27 != 0x0)
        reg_debug_2 =0x1c;
    if (reg_mprj_io_28 != 0x0)
        reg_debug_2 =0x1d;
    if (reg_mprj_io_29 != 0x0)
        reg_debug_2 =0x1e;
    if (reg_mprj_io_30 != 0x0)
        reg_debug_2 =0x1f;
    if (reg_mprj_io_31 != 0x0)
        reg_debug_2 =0x20;
    if (reg_mprj_io_32 != 0x0)
        reg_debug_2 =0x21;
    if (reg_mprj_io_33 != 0x0)
        reg_debug_2 =0x22;
    if (reg_mprj_io_34 != 0x0)
        reg_debug_2 =0x23;
    if (reg_mprj_io_35 != 0x0)
        reg_debug_2 =0x24;
    if (reg_mprj_io_36 != 0x0)
        reg_debug_2 =0x25;
    if (reg_mprj_io_37 != 0x0)
        reg_debug_2 =0x26;
        // housekeeping
    if (reg_hkspi_status  != old_reg_hkspi_status) // RO
        reg_debug_2 =0x27;
    if (reg_hkspi_chip_id  != old_reg_hkspi_chip_id) // RO
        reg_debug_2 =0x28;
    if (reg_hkspi_user_id  != old_reg_hkspi_user_id) // RO
        reg_debug_2 =0x29;
    if (reg_hkspi_pll_ena  != 0x0)  // size =2
        reg_debug_2 =0x2a;
    if (reg_hkspi_pll_bypass != 0x0) // size = 1
        reg_debug_2 = 0x2b;
    if (reg_hkspi_irq  != old_reg_hkspi_irq)  // RO
        reg_debug_2 = 0x2c;
    if (reg_hkspi_trap  != old_reg_hkspi_trap)  // RO
        reg_debug_2 =0x2d;
    if (reg_hkspi_pll_trim  != 0x0) // size 26
        reg_debug_2 = 0x2f;
    if (reg_hkspi_pll_source  != 0x0) // size 6 bits 0-2 = phase 0 divider, bits 3-5 = phase 90 divider
        reg_debug_2 =0x2f;
    if (reg_hkspi_pll_divider  != 0x0) // size 7 -> PLL output divider, PLL output divider2 , PLL feedback divider
        reg_debug_2 =0x30;
    if (reg_hkspi_disable  != 0x0) // size 1
        reg_debug_2 =0x31;
    if (reg_clk_out_dest  != 0x0) // trap and clocks redirect
        reg_debug_2 =0x32;
        
    reg_debug_2 = 0xFF;
}

